<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Drawing Board</title>
    <!-- Include jsPDF from CDN for PDF generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
        }

        #toolbar {
            margin: 10px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn, .color-picker, .select {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .btn {
            background-color: #333;
            color: #fff;
        }

        .btn:hover {
            background-color: #555;
        }

        .color-picker {
            cursor: pointer;
        }

        .select {
            background-color: #fff;
            border: 1px solid #ccc;
        }

        #canvas-container {
            position: relative;
            border: 2px solid #333;
            background-color: #fff;
        }

        canvas {
            display: block;
        }

        #background-input {
            display: none;
        }

        /* Slide Indicators */
        #slides-indicators {
            margin-top: 10px;
            display: flex;
            gap: 5px;
        }

        .slide-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #ccc;
            cursor: pointer;
        }

        .active-dot {
            background-color: #333;
        }
    </style>
</head>
<body>
    <div id="toolbar">
        <!-- Color Picker -->
        <input type="color" id="color-picker" class="color-picker" title="Choose color">
        
        <!-- Brush Size -->
        <select id="brush-size" class="select" title="Brush Size">
            <option value="2">2px</option>
            <option value="4">4px</option>
            <option value="6">6px</option>
            <option value="8">8px</option>
            <option value="10">10px</option>
        </select>
        
        <!-- Shape Selector -->
        <select id="shape-selector" class="select" title="Select Shape">
            <option value="freehand">Freehand</option>
            <option value="line">Line</option>
            <option value="rectangle">Rectangle</option>
            <option value="circle">Circle</option>
        </select>
        
        <!-- Background Color Picker -->
        <input type="color" id="bg-color-picker" class="color-picker" title="Background Color">
        
        <!-- Background Image Upload -->
        <button id="bg-image-btn" class="btn">Set Background Image</button>
        <input type="file" id="background-input" accept="image/*">
        
        <!-- Slide Controls -->
        <button id="add-slide" class="btn">Add Slide</button>
        <button id="prev-slide" class="btn">Previous Slide</button>
        <button id="next-slide" class="btn">Next Slide</button>
        
        <!-- Clear Canvas -->
        <button id="clear-board" class="btn">Clear</button>
        
        <!-- Save as PDF -->
        <button id="save-pdf" class="btn">Save as PDF</button>
    </div>

    <div id="canvas-container">
        <canvas id="drawing-board" width="800" height="600"></canvas>
    </div>

    <div id="slides-indicators"></div>

    <script>
        const { jsPDF } = window.jspdf;

        const canvas = document.getElementById('drawing-board');
        const ctx = canvas.getContext('2d');
        const colorPicker = document.getElementById('color-picker');
        const bgColorPicker = document.getElementById('bg-color-picker');
        const brushSize = document.getElementById('brush-size');
        const shapeSelector = document.getElementById('shape-selector');
        const clearButton = document.getElementById('clear-board');
        const bgImageBtn = document.getElementById('bg-image-btn');
        const backgroundInput = document.getElementById('background-input');
        const addSlideBtn = document.getElementById('add-slide');
        const prevSlideBtn = document.getElementById('prev-slide');
        const nextSlideBtn = document.getElementById('next-slide');
        const savePdfBtn = document.getElementById('save-pdf');
        const slidesIndicators = document.getElementById('slides-indicators');

        let isDrawing = false;
        let startX = 0;
        let startY = 0;
        let currentShape = 'freehand';
        let currentColor = '#000000';
        let currentBrushSize = 2;
        let backgroundColor = '#ffffff';
        let backgroundImage = null;

        // Slides Management
        let slides = [];
        let currentSlide = 0;

        // Initialize first slide
        addSlide();

        function addSlide() {
            slides.push({
                drawings: [], // To store drawing actions
                backgroundColor: backgroundColor,
                backgroundImage: backgroundImage
            });
            currentSlide = slides.length - 1;
            updateSlidesIndicators();
            renderSlide();
        }

        function updateSlidesIndicators() {
            slidesIndicators.innerHTML = '';
            slides.forEach((_, index) => {
                const dot = document.createElement('div');
                dot.classList.add('slide-dot');
                if (index === currentSlide) {
                    dot.classList.add('active-dot');
                }
                dot.addEventListener('click', () => {
                    currentSlide = index;
                    renderSlide();
                    updateSlidesIndicators();
                });
                slidesIndicators.appendChild(dot);
            });
        }

        function renderSlide() {
            const slide = slides[currentSlide];
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Set background
            if (slide.backgroundImage) {
                const img = new Image();
                img.src = slide.backgroundImage;
                img.onload = () => {
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    redrawDrawings();
                };
            } else {
                ctx.fillStyle = slide.backgroundColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                redrawDrawings();
            }
        }

        function redrawDrawings() {
            const slide = slides[currentSlide];
            slide.drawings.forEach(action => {
                ctx.strokeStyle = action.color;
                ctx.lineWidth = action.size;
                ctx.lineCap = 'round';

                if (action.type === 'freehand') {
                    ctx.beginPath();
                    ctx.moveTo(action.from.x, action.from.y);
                    ctx.lineTo(action.to.x, action.to.y);
                    ctx.stroke();
                } else if (action.type === 'line') {
                    ctx.beginPath();
                    ctx.moveTo(action.from.x, action.from.y);
                    ctx.lineTo(action.to.x, action.to.y);
                    ctx.stroke();
                } else if (action.type === 'rectangle') {
                    ctx.strokeRect(action.from.x, action.from.y, action.width, action.height);
                } else if (action.type === 'circle') {
                    ctx.beginPath();
                    ctx.arc(action.from.x, action.from.y, action.radius, 0, 2 * Math.PI);
                    ctx.stroke();
                }
            });
        }

        // Event Listeners
        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            [startX, startY] = [e.offsetX, e.offsetY];
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;

            const mouseX = e.offsetX;
            const mouseY = e.offsetY;

            if (currentShape === 'freehand') {
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = currentBrushSize;
                ctx.lineCap = 'round';

                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(mouseX, mouseY);
                ctx.stroke();

                // Save the drawing action
                slides[currentSlide].drawings.push({
                    type: 'freehand',
                    from: { x: startX, y: startY },
                    to: { x: mouseX, y: mouseY },
                    color: currentColor,
                    size: currentBrushSize
                });

                [startX, startY] = [mouseX, mouseY];
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (!isDrawing) return;
            isDrawing = false;
            const mouseX = e.offsetX;
            const mouseY = e.offsetY;

            if (currentShape === 'line') {
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = currentBrushSize;
                ctx.lineCap = 'round';

                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(mouseX, mouseY);
                ctx.stroke();

                slides[currentSlide].drawings.push({
                    type: 'line',
                    from: { x: startX, y: startY },
                    to: { x: mouseX, y: mouseY },
                    color: currentColor,
                    size: currentBrushSize
                });
            } else if (currentShape === 'rectangle') {
                const width = mouseX - startX;
                const height = mouseY - startY;
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = currentBrushSize;

                ctx.strokeRect(startX, startY, width, height);

                slides[currentSlide].drawings.push({
                    type: 'rectangle',
                    from: { x: startX, y: startY },
                    width: width,
                    height: height,
                    color: currentColor,
                    size: currentBrushSize
                });
            } else if (currentShape === 'circle') {
                const radius = Math.sqrt(Math.pow(mouseX - startX, 2) + Math.pow(mouseY - startY, 2));
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = currentBrushSize;

                ctx.beginPath();
                ctx.arc(startX, startY, radius, 0, 2 * Math.PI);
                ctx.stroke();

                slides[currentSlide].drawings.push({
                    type: 'circle',
                    from: { x: startX, y: startY },
                    radius: radius,
                    color: currentColor,
                    size: currentBrushSize
                });
            }
        });

        canvas.addEventListener('mouseout', () => isDrawing = false);

        // Control Handlers
        colorPicker.addEventListener('input', (e) => {
            currentColor = e.target.value;
        });

        bgColorPicker.addEventListener('input', (e) => {
            backgroundColor = e.target.value;
            slides[currentSlide].backgroundColor = backgroundColor;
            slides[currentSlide].backgroundImage = null;
            renderSlide();
        });

        brushSize.addEventListener('change', (e) => {
            currentBrushSize = e.target.value;
        });

        shapeSelector.addEventListener('change', (e) => {
            currentShape = e.target.value;
        });

        clearButton.addEventListener('click', () => {
            const confirmClear = confirm("Are you sure you want to clear the current slide?");
            if (confirmClear) {
                slides[currentSlide].drawings = [];
                renderSlide();
            }
        });

        bgImageBtn.addEventListener('click', () => {
            backgroundInput.click();
        });

        backgroundInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                backgroundImage = event.target.result;
                slides[currentSlide].backgroundImage = backgroundImage;
                slides[currentSlide].backgroundColor = '#ffffff'; // Reset background color
                renderSlide();
            };
            reader.readAsDataURL(file);
        });

        addSlideBtn.addEventListener('click', () => {
            addSlide();
        });

        prevSlideBtn.addEventListener('click', () => {
            if (currentSlide > 0) {
                currentSlide--;
                renderSlide();
                updateSlidesIndicators();
            }
        });

        nextSlideBtn.addEventListener('click', () => {
            if (currentSlide < slides.length - 1) {
                currentSlide++;
                renderSlide();
                updateSlidesIndicators();
            }
        });

        savePdfBtn.addEventListener('click', () => {
            const slide = slides[currentSlide];
            const pdf = new jsPDF('landscape', 'px', [canvas.width, canvas.height]);

            // Create a temporary canvas to combine background and drawings
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');

            // Set background
            if (slide.backgroundImage) {
                const img = new Image();
                img.src = slide.backgroundImage;
                img.onload = () => {
                    tempCtx.drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);
                    drawOnTempCanvas();
                };
            } else {
                tempCtx.fillStyle = slide.backgroundColor;
                tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                drawOnTempCanvas();
            }

            function drawOnTempCanvas() {
                // Redraw all drawings
                slide.drawings.forEach(action => {
                    tempCtx.strokeStyle = action.color;
                    tempCtx.lineWidth = action.size;
                    tempCtx.lineCap = 'round';

                    if (action.type === 'freehand') {
                        tempCtx.beginPath();
                        tempCtx.moveTo(action.from.x, action.from.y);
                        tempCtx.lineTo(action.to.x, action.to.y);
                        tempCtx.stroke();
                    } else if (action.type === 'line') {
                        tempCtx.beginPath();
                        tempCtx.moveTo(action.from.x, action.from.y);
                        tempCtx.lineTo(action.to.x, action.to.y);
                        tempCtx.stroke();
                    } else if (action.type === 'rectangle') {
                        tempCtx.strokeRect(action.from.x, action.from.y, action.width, action.height);
                    } else if (action.type === 'circle') {
                        tempCtx.beginPath();
                        tempCtx.arc(action.from.x, action.from.y, action.radius, 0, 2 * Math.PI);
                        tempCtx.stroke();
                    }
                });

                // Convert to image and add to PDF
                const imgData = tempCanvas.toDataURL('image/png');
                pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);
                pdf.save(`slide_${currentSlide + 1}.pdf`);
            }
        });
    </script>
</body>
</html>